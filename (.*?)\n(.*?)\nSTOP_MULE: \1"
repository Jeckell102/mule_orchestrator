matches = re.findall(pattern, proposal, re.DOTALL)
        
        if not matches:
            print("‚ö†Ô∏è [FILE SYSTEM] No 'START_MULE' tags found in approved plan.")
            return False

        for filename, content in matches:
            filepath = os.path.join(BASE_DIR, filename.strip())
            try:
                with open(filepath, "w") as f:
                    f.write(content.strip())
                print(f"üíæ [SAVED] {filename}")
            except Exception as e:
                print(f"‚ùå [ERROR] Writing {filename}: {e}")
                return False
        return True

    def run(self):
        print(f"‚úÖ [SETUP] Orchestrating: {self.expert_chain}")
        file_context = self.inject_context()
        final_proposal = ""
        status = "INCOMPLETE"

        for role in self.expert_chain:
            self.current_cycle += 1
            model_name = self.get_model(role)
            print(f"üîÑ [CYCLE {self.current_cycle}] {role} processing with {model_name}...")
            
            model = genai.GenerativeModel(
                model_name=model_name,
                system_instruction=self.personas.get(role)
            )
            
            # The Chain Memory: Each expert sees the history of the previous experts
            chain_context = f"TASK: {self.prompt}\n\nPREVIOUS EXPERT FINDINGS:\n" + "\n".join(self.history)
            input_text = f"{chain_context}\n\nPROJECT FILES:\n{file_context}"
            
            try:
                response = model.generate_content(input_text).text
                self.history.append(f"--- {role} OUTPUT ---\n{response}")
                final_proposal = response
            except Exception as e:
                print(f"‚ùå [API ERROR @ {role}]: {e}")
                break

            # The User Gate: Allows you to intervene or approve at any stage
            if "DO YOU WISH TO APPLY" in response.upper() or "[READY]" in response.upper():
                print("\n" + "‚ïê"*40 + f"\n‚ö†Ô∏è  {role} PROPOSES ACTION\n" + "‚ïê"*40)
                print(response.strip()[:1500] + "...") # Preview first 1500 chars
                
                print("\nOptions: (y)es=Apply Code, (n)ext=Force Next Expert, (f)eedback=Critique, (q)uit")
                decision = input(">> DECISION: ").strip().lower()
                
                if decision == 'y':
                    if self.apply_code_changes(response):
                        status = "VALIDATED"
                        print("‚úÖ [COMMIT SUCCESS] Code updated.")
                    break
                elif decision == 'n':
                    print("‚è© Forcing handoff to next specialist...")
                    continue
                elif decision == 'f':
                    feedback = input("Enter feedback: ")
                    self.history.append(f"USER FEEDBACK: {feedback}")
                    # Decrement cycle so we retry this role with feedback
                    self.current_cycle -= 1 
                    continue 
                elif decision == 'q':
                    status = "ABORTED"
                    break
                
        print("\nüöÄ [ORCHESTRATION COMPLETE]")
        self.finalize_log(status, final_proposal)

    def finalize_log(self, status, proposal):
        conn = self.init_db()
        try:
            conn.execute("INSERT INTO mule_audit VALUES (?, ?, ?, ?, ?, ?, ?)", 
                         (str(datetime.datetime.now()), self.prompt, status, self.current_cycle, 
                          str(self.history), proposal, "Multi-Agent-Chain"))
            conn.commit()
        except Exception as e:
            print(f"‚ö†Ô∏è [LOGGING ERROR]: {e}")
        conn.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("start")
    parser.add_argument("--prompt", required=True)
    args = parser.parse_args()
    
    orchestrator = MuleOrchestrator(args.prompt)
    orchestrator.run()